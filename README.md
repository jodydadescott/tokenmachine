# Tokenmachine

Tokenmachine grants Secrets or Kerberos Keytabs to bearers of JWT Tokens authorized by
Open Policy Agent (OPA) Rego. Tokens2Secrets is a bridge between the old world of shared
secrets and Kerberos Keytabs and the new world of Tokens.

Kerberos works by issuing tickets to users or machines that prove their identity with
a username or principal and password. Daemonized applications, especially ones not part
of a Kerberos domain, are often assigned Keytabs. Keytabs are files generated by the
Directory Admin. A Keytab contains one or more principals and the corresponding password
that is encrypted with the directory secret. Keytabs can be used to obtain Kerberos
tickets. Note that most Keytabs hold only one principal.

A Keytab or more specifically the principal is valid until the account is disabled or the
password is changed. This creates a security hole as Keytabs are by there very nature
long lived. No one wants to go around and change them out all the time. Its lots of work
and something may go wrong. It is not uncommon for Keytabs to be valid for years.

Tokens have become very popular with the rise of companies such as AWS, Okta and Google.
The industry has gravitated towards JSON Web Tokens (JWT) and OAUTH/OIDC. These tokens
are analogus to Kerberos tickets but unlike Kerberos tickets they hold information about
the bearer and can be verified by third parties. This is because they include an issuer.
This allows for verification by fetching the issuers public key and validating the token
included signature.

This project seeks to provide a bridge between these two different worlds by issuing
Kerberos Keytabs to bearers of tokens with authorized claims (or tags). Authorization
is performed by executing an Open Policy Agent (OPA) Rego policy. If authorized the
bearer of said token will be issued a Keytab that will have a validity based on
preconfigured time periods.

Operatioally the process works like this. The bearer obtains a token from their identity
provider (IDP) and makes a request to the Tokens2Secrets server for a nonce. The
Tokens2Secrets server uses the bearers token to see if they are authorized to get a
nonce. If so a new nonce is created with an expiration time based on configuration and
returned to the bearer. The bearer then obtains a new token from their identity provider
with the audience (aud) field set to the nonce. This is to prevent a replay attack. The
bearer uses this new token to request a Keytab with a desired principal from the
Tokens2Secrets server. The Tokens2Secrets server validats the nonce and executes the OPA
policy to authorize that the bearer is entitled to the Keytab. If the bearer is entitiled
the Keytab is returned as a JSON object with both the Keytab file as a Base64 encoded
file and the Keytab expiration time.

It is important to understand that the Keytab expiration operates indepentley of the
request time. For example if the Keytab is configured for a five minute lifetime then
the Keytab expiration will be based on the five minute periods since epoch. So if the
Keytab is requested at 04:30 of a five minute period the bearer may or may not have
enough time to make effective use of the Keytab before expiration. In this situation
if is up to the bearer to check the expiration time and if necessary and request the
Keytab again if necessary. If this does happen the bearer can request the Keytab with
the same nonce as the nonce does not expire on use but on time. Note that the nonce
expiration is based on the creation of the nonce (unlike the Keytab).

In practice the bearer should request a Keytab, decoded the Base64 file to a scratch
file, obtain a Kerberos ticket and then discard the Keytab by deleting the file.

Tokens2Secrets may be ran on Windows, Linux or Darwin but valid Keytabs will only
be issued if running on Windows. This is because the utility ktpass.exe is used
to generate the Keytabs.

## Installation

### Windows

For Windows it is intended to run the server as a Windows service. The binary is able
to install itself as a service and even start itself. Installation consist of placing
the binary in a desired location, setting the config(s), installing the service and
finally starting the service.

It is importnat that the service be configured to run as a Directory Admin. This is
required for the creation of keytabs.

The config will be covered below but on Windows a comma delineated list of configs is
stored in the Windows registry. This can be set and shown using the same binary.

Create a directory such as 'C:\Program Files\Tokens2Secrets' and install the binary
'tokens2Secrets.exe' into said direcotry. Using the Windows command prompt change
directory to the installation directory and perform the following task.

```bash
# Install the service
.\tokenmachine.exe service install

# Create an example config then edit it
.\tokenmachine.exe config example > example.yaml

# Set the config(s) where $CONFIG_FILES with the location to one or more config files or
#  http(s) urls
.\tokenmachine.exe service config set $CONFIG_FILES

# When ready start the service
.\tokenmachine.exe service start
```

### Linux and Darwin

Download and install the binary tokenmachine. Note that valid Keytabs will NOT
be issued on Linux and Darwin.

```bash
# Create an example config then edit it
./tokenmachine config example > example.yaml

# Run the server with
./tokenmachine --config example.yaml
```

## Configuration

### Overview

The config is provided by one or more files that may be JSON, YAML, or Rego. The config
may be located on the local disk or on a remote http(s) server such as GitHub. The config
can be in a single file or multiple files. When the config is located in multiple files
the config will be processed in order. It is possible to use both local and remote
configs.

The configuration requires a secret seed. This should remain secret. This can be
accompolished by breaking the configuration up into two files where the main file
contains all of the non-sensitive config and the other file contains the seed secret.
The main file can be located on a repo an accessible via http(s) or on the local
filesystem. The seed config should be stored on the local filesystem and with restrictive
read/write permissions.

One method would be to locate the non-sensitive config on a remote http(s) server and the
sensitive config on the local disk with restrictive read and write permissions. Or both
configs could be kept on disk as seperate files. Another method would be to keep the
non-sensitive data on a repo and the seed in a vault. Then they could be combined into a
single config by a script at runtime and set with restricitive read and write
permissions.

### Example

```yaml
# This is the config version.
apiVersion: V1
network:
  # THe interface to listen on. By default it is any.
  # listen: any
  # The port to run the HTTP and or HTTPS server on. If it is not set then it will not
  # be started. Either the HTTP or HTTPS server must be enabled. If the HTTPS server is
  # enabled both tlscert and tlsKey must be set
  httpPort: 8080
  # httpsPort: 8443
  # tlscert: |-
  #   -----BEGIN CERTIFICATE-----
  #   ................................................................
  #   ................................................................
  #   ................................................................
  #   ................................................................
  #   ................................................................
  #   ................................................................
  #   ................................................................
  #   ................................................................
  #   ................................................................
  #   ................................................................
  #   ................................................................
  #   ....................................
  #   -----END CERTIFICATE-----
  # tlsKey: |-
  #   -----BEGIN EC PRIVATE KEY-----
  #   ................................................................
  #   ................................................................
  #   ................................................................
  #   ................................
  #   -----END EC PRIVATE KEY-----
policy:
  #
  # This is a OPA/Rego Policy. It must have the package name main and expose
  # the boolean functions auth_get_nonce and auth_get_keytab.
  #
  # The input format structure has claims []string, principal and nonce string.
  #
  policy: |2

    package main

    default auth_get_nonce = false
    default auth_get_keytab = false

    auth_base {
       # Here we match that the token issuer is an authorized issuer
       input.claims.iss == "abc123"
    }

    auth_get_nonce {
      # For now all we are doing is calling auth_base. This could be expanded as needed.
       auth_base
    }

    auth_nonce {
       # To prevent replay attack we compare the nonce from the user with the nonce in
       # the token claims. Here we expect the nonce from the user to match the audience
       # (aud) field. If our token issuer uses a different claim we will need to adjust
       # as necessary.
       input.claims.aud == input.nonce
    }

    auth_get_keytab {
       # Here we auth the principals requested by the user. We use claims from the token
       # provider to determine is the bearer should be authorized. Our token provider has
       # the authorized principals in a comma delineated string under the string array
       # service which is under the claims. We split the comma string into a set and
       # check for a match
       auth_base
       split(input.claims.service.keytab,",")[_] == input.principal
    }
  # This is the lifetime of a Nonce in seconds
  nonceLifetime: 1m0s

  # This is the default lifetime of a Keytab in seconds. This is the lifetime that will
  # be used if the specific Keytab does not have a lifetime configured.
  keytabLifetime: 60

logging:
  # This should be debug, info, warn or error. Default is info.
  logLevel: info
  # This should be json or console. Default is json.
  logFormat: json

  # The outputPaths and errorOutputPaths should be one or more of stderr, stdout, and/or
  # file. By default it is stderr. Note that on Windows when running as a service events
  # will be sent to the Windows event logger irregardless of this setting.
  outputPaths:
    - stderr
  errorOutputPaths:
    - stderr
data:
  # This is the set or principals that Keytabs will be issued for. These principals
  # should already exist on the target domain.
  principals:
    - superman@EXAMPLE.COM
    - birdman@EXAMPLE.COM
```

For testing a selfsigned cert can be generated with the following commands

```bash
openssl ecparam -genkey -name secp384r1 -out server.key
openssl req -new -x509 -sha256 -key server.key -out server.crt -days 3650
```
